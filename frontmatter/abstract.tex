%!TEX root = ../dissertation.tex


Android applications frequently embed native C/C++ libraries accessed via the \gls{jni}, introducing memory-safety risks that may compromise the entire application despite the sandbox. Large-scale fuzzing systems such as POIROT generate thousands of crashes for these libraries, but their triage remains manual, slow, and difficult to scale. %When contextual information is incomplete or noisy, the classification of these crashes becomes even more challenging, and general-purpose LLMs tend to over-predict vulnerabilities.

%Aim:
To improve the scalability of crash triage for Android native libraries, this thesis quantifies whether an \gls{llm} \textcolor{red}{equipped with \gls{mcp} for retrieving code context}, can reliably classify fuzzing-generated crashes and distinguish benign faults from real vulnerabilities.

%Approach:
%A structured, automated triage workflow is developed by combining \gls{llm} with reverse-engineering tools exposed through the \gls{mcp}. Crash artefacts generated by POIROT (stack traces and \gls{jni} entry points) and enriched with contextual evidence, such as a \gls{jcg} and a native map , ... retrieved live from Jadx (Java/DEX decompilation) and Ghidra (native disassembly). The LLM analyses each crash using a meta-prompt and a strict JSON schema, leveraging a filtered Java-to-native call graph and per-library code inspection to produce a grounded vulnerability assessment including severity, CWE mapping, evidence items, and exploitability indicators.

A structured, automated triage workflow is developed by combining \gls{llm} with reverse-engineering tools exposed through the \gls{mcp}. Crash artefacts generated by POIROT, \textcolor{red}{a state-of-the-art system that automatically synthesises fuzzing harnesses for Android native libraries and produces crash outputs such as stack traces}, are enriched with contextual evidence retrieved from Jadx (Java/DEX decompilation) and Ghidra (native decompilation). The \gls{llm} analyses each crash following a \textcolor{red}{prompt that enforces structured reasoning} and a strict JSON schema, leveraging a filtered Java-to-native call graph and a map of crash-relevant native methods to produce a grounded vulnerability assessment including severity, \glsxtrshort{cwe} mapping, evidence items, and exploitability indicators.



%Results:
\textcolor{red}{66~\% -> ma non avevi quest'accuracy già dando il call graph all'LLM?}
Across 137 crashes from 80 real-world applications, the system achieves an overall accuracy of 66~\%, with a low false-negative rates (3–5~\%). When Java-side context is available through a filtered \gls{jcg}, accuracy increases to 77~\% and precision more than doubles, confirming the importance of cross-layer information in reducing over-approximation. A detailed case study on TP-LINK’s tpCamera reproduces and correctly characterises the real vulnerability later assigned CVE-2023-30273, demonstrating that the system can recover expert-level reasoning patterns using structured evidence.

%Conclusions:
The findings show that \gls{llm}-based crash triage, when grounded through \gls{mcp}-mediated retrieval of Java and native context, provides a practical and scalable first-line vulnerability assessment mechanism for Android native libraries. While not a substitute for manual auditing, the workflow improves consistency, reduces analyst effort, and offers structured, evidence-driven starting points for further security investigation.


\begin{comment}
    
Android applications frequently embed native C/C++ libraries accessed through the \gls{jni}, introducing memory-safety risks that can compromise the entire app despite the protections of the Android sandbox. Recent systems, such as POIROT, enable large-scale fuzzing of these native libraries and generate extensive crash reports, but the triage of such crashes remains largely manual, time-consuming, and difficult to scale.

This thesis presents an automated, evidence-driven crash–triage pipeline based on \glspl{llm} equipped with tool-mediated context retrieval through the \gls{mcp}. The system takes POIROT crash artefacts as input and classify them with information obtained from two \gls{mcp}-exposed reverse-engineering backends: Jadx, for Java decompilation and manifest inspection of the \glsxtrshort{apk}, and Ghidra, for the decompilation of native libraries.

The \glspl{llm}, guided by a structured meta-prompt and a strict JSON schema, analyse each crash artefact along with a Java-to-native call graph and a mapping of crash-relevant native methods and corresponding libraries. Using this structured context, they produce a grounded vulnerability assessment that includes severity, \glsxtrshort{cwe} identifiers, evidence items, and, when a crash is marked as vulnerable, an exploitability analysis.

The evaluation uses 137 crashes from 80 real-world applications. Results show consistently low false-negative rates (3--5\%), with an overall accuracy of 66\%. When Java-side context is available through a filtered \gls{jcg}, accuracy rises to 77\% and precision more than doubles, demonstrating the importance of cross-layer information for reducing over-approximation. A detailed case study on the TP-LINK tpCamera application further illustrates the system’s capabilities. The triager correctly identifies the vulnerability later assigned CVE-2023-30273, reconstructing its root cause and impact using stack evidence and decompiled code.

Overall, the results indicate that \gls{llm}-based crash triage, when combined with verifiable program context obtained through \gls{mcp}, offers a practical and scalable direction for vulnerability analysis of Android native libraries. While not a replacement for manual auditing, the system provides an efficient first-line filter that improves consistency, reduces analyst workload, and supplies structured, evidence-backed starting points for deeper security investigation.

\end{comment}