\chapter{Discussion}
\label{chp:disc}

\section{Tool Performance and Efficiency}

The implemented pipeline demonstrates acceptable and promising operational performance.  


\textit{Single-crash} analysis by the \gls{llm} requires on average less than a minute, which makes the approach scalable and significantly accelerates the classification process.
However, the total execution time per application depends heavily on fuzzing procedure, the crash count of method, the complexity of native stack traces, and the number of native libraries involved.  
In applications with many or large native libraries, the overhead caused by importing and decompiling binaries can substantially increase the total runtime, this overhead originates from the reverse-engineering tools rather than from the analysis performed by the model.

\section{Effect of \glsxtrlong{jcg}}

As seen in Chapter~\ref{chp:result}, the comparison between analyses performed with or without the \gls{jcg} yields a clear trade-off:

\begin{myitemize}
    \item When the \glsxtrlong{jcg} is available (“With \glsxtrshort{jcg}”), the model can leverage both native and Java-level context, producing more coherent and realistic vulnerability assessments. Under this configuration, the system achieves higher recall and maintains relatively few false negatives.
    \item Without the \glsxtrlong{jcg} (“Without \glsxtrshort{jcg}”), the lack of Java-side context leads the model to over-approximate risks. Without knowing the origin or constraints of the data, the system tends to treat values as attacker-controlled, even when in reality they may originate from fixed Java-side logic and be impossible for an attacker to influence.
\end{myitemize}




\section{Reliability}

The pipeline exhibits a low number of False Negatives, indicating that genuine vulnerabilities are rarely overlooked. This behaviour is partly influenced by the \gls{llm}'s tendency to classify ambiguous memory-related faults (e.g., buffer errors, JNI misuse, invalid native calls) as potentially dangerous. Prior studies highlight similar patterns: general-purpose models often over-predict positives, hallucinate tool behaviour, or misinterpret control-flow semantics~\cite{10456393,ullah2024llmsreliablyidentifyreason}. 

\section{Limitations}

The evaluation performed in this thesis is subject to several limitations that affect the results.

The quality of the classification strongly depends entirely on the crash traces produced by POIROT. When stack trace contain missing or unresolved entries (marked as ``\texttt{??}''), the model lacks essential execution context and tends to assume a worst-case scenario, contributing to the high false-positive rate observed in the evaluation.

The dataset, though representative of diverse applications, cannot fully capture the variability of real-world Android ecosystems. 



%-------------------------------------------------------------------------
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------



\section{Comparison with Ground-Truth Vulnerability}
\label{sec:comparison_tpcamera}

To evaluate the quality of the \gls{llm}-based triage, this section compares the model’s classification of a real vulnerability in the \texttt{tpCamera} application with the ground truth reported in the POIROT paper~\cite{poirot-usenix25}.  
The vulnerability, later assigned CVE-2023-30273, concerns a use-after-free condition in the native MP4 encoding library.

\subsection{Ground-Truth Summary}
Section~5.6 of the POIROT paper describes a reproducible use-after-free vulnerability in the \texttt{libTPMp4Encoder.so} library.  
The flaw arises when the application invokes the MP4 encoding pipeline with malformed JPEG or H.264 data:

\begin{itemize}
    \item The JNI function \texttt{packVideo} receives attacker-controlled frame data and a size parameter.
    \item The native function \texttt{mp4\_write\_one\_h264} tears down the encoder context on malformed input: it closes the file, frees multiple internal buffers, and finally frees the global structure \texttt{iniPacker\_global} itself.
    \item A second invocation of \texttt{packVideo} reuses the same freed encoder context, triggering a \emph{use-after-free} where the freed structure is overwritten by attacker-controlled data.
    \item The overwritten structure corrupts the file pointer passed to \texttt{fclose()}, enabling arbitrary code execution under certain conditions.
\end{itemize}

The exploit is reproducible with a precise call sequence (\texttt{iniPacker} → \texttt{packVideo} → second \texttt{packVideo}) and was validated both locally and through a MITM attack against the tpCamera app.

\subsection{LLM Classification Summary}
\ref{out}

The \gls{llm}-based triage correctly identifies the crash in \texttt{tpCamera} as a genuine vulnerability, assigning a high severity level and a confidence score of 0.85.  
The model attributes the crash to a memory-safety error in the native MP4 encoding pipeline, centred around the logic implemented in the \texttt{mp4\_write\_one\_h264} routine in \texttt{libTPMp4Encoder.so}.

The full classification output for this application is provided in Appendix~\ref{chp:appendixA}.

\medskip

\noindent The classification highlights three main contributing factors:

\begin{itemize}
    \item \textbf{Unvalidated size parameter}: The JNI method \texttt{packVideo} forwards an unbounded, attacker-influenced size directly to the native encoder without consistency checks.
    
    \item \textbf{Unsafe error-handling path}: On malformed Network Abstraction Layer (NAL) input, \texttt{mp4\_write\_one\_h264} frees multiple internal buffers and then frees the encoder context itself, while higher-level code may continue using the same structure.

    \item \textbf{Potential heap corruption and double free}: Repeated calls on a freed context can corrupt heap metadata, consistent with the crash \texttt{scudo::reportInvalidChunkState}.
\end{itemize}

The model concludes that the vulnerability likely enables heap corruption or a double-free/use-after-free condition, mapping it to CWE-787 (Out-of-bounds Write), CWE-415 (Double Free), and CWE-416 (Use After Free).  
It also identifies a plausible exploitation vector: \texttt{"trigger\_method"}: ``Malformed H.264 frame buffer passed via MP4Encoder.packVideo with inconsistent size parameter''.

\subsection{Comparison with Ground Truth}

The \gls{llm}-generated analysis aligns closely with the ground-truth description reported in the POIROT paper~\cite{poirot-usenix25}.  
Both sources identify the vulnerability as a use-after-free condition arising from repeated invocations of \texttt{packVideo} on a freed encoder context.

\paragraph{\glsxtrlong{llm} classification compared with PIROT}

\begin{itemize}
    \item \textbf{Root cause agreement}: The analysis matches the PIROT description, recognising that the encoder context (\texttt{iniPacker\_global}) is freed on malformed input and later reused, enabling a use-after-free.
    \item \textbf{Impact on file handling}: The classification highlights that tearing down and reusing the encoder context affects file and stream management, which is consistent with the PIROT finding that corruption of this context can influence the \texttt{FILE*} pointer passed to \texttt{fclose()}.
    \item \textbf{Attack preconditions}: It correctly notes that the vulnerability is remotely triggerable through malformed video frames delivered over an untrusted network channel.
    \item \textbf{Code execution potential}: The analysis further infers that this memory-safety primitive can lead to arbitrary function invocation or code execution under realistic conditions.
\end{itemize}

Overall, the model captures the key structural and behavioural elements of the vulnerability, providing an analysis that is consistent with the real exploit chain reported in the ground-truth study.

\subsection{Interpretation of Results}

This comparison shows that the \gls{llm}-based triage is capable of reconstructing the essential characteristics of a complex native vulnerability using only stack-trace evidence, decompiled code, and contextual information accessed through \gls{mcp} tools.  
The model correctly identifies the use-after-free pattern, the conditions that lead to encoder-state corruption, and the attacker-controlled inputs required to reach the vulnerable code paths.

The analysis produced by the model is not only consistent with the POIROT ground truth, but also captures several realistic exploitation vectors.  
Its focus on the unvalidated size parameter, while not explicitly central in the POIROT paper, illustrates the model's ability to reason about alternative failure modes that could plausibly contribute to heap corruption in similar contexts.

The case study demonstrates that the proposed pipeline can approximate expert-level reasoning and align closely with real-world vulnerability reports, validating its effectiveness as an initial triage mechanism.

