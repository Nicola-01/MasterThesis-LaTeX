\chapter{Preliminaries}
\label{chp:preliminaries}

%\section{POIROT}

\begin{comment}
    \section{Goal and setting.}
\emph{POIROT} targets commercial Android applications that embed native C/C++ libraries invoked through the \gls{jni}. Its goal is to discover security-relevant defects by \emph{automatically} building a realistic, consumer-specific fuzzing harness that mirrors how the app actually exercises its native library, and then running coverage-guided fuzzing at scale \cite{poirot-usenix25}.

\section{Key idea.}
Instead of relying on generic, library-centric drivers, POIROT recovers the \emph{app’s} usage of the library from Dalvik bytecode and synthesises a harness that supports \emph{bidirectional} \gls{jni} interactions. The harness initialises app-relevant state, invokes native entry points following app-specific call sequences, and preserves argument/value constraints discovered in the managed code, thereby increasing the likelihood of reaching security-critical behaviours during fuzzing \cite{poirot-usenix25}.

\section{Inputs and outputs.}
Given an APK and its embedded native libraries, POIROT:
\begin{enumerate}
  \item analyses \gls{dex} to extract \emph{consumer usage}: call sites to native methods, inter-procedural call sequences, and salient argument/value flows across the \gls{jni} boundary;
  \item synthesises a consumer-specific harness that loads the target library and replays realistic \gls{jni} interactions;
  \item executes a coverage-guided fuzzing campaign on Android virtual devices and records crashes.
\end{enumerate}
For each crash, POIROT emits artefacts used later by our triager:
\begin{itemize}
  \item \textbf{Crash report:} signal or sanitizer class, faulting address/PC, and (where available) backtrace;
  \item \textbf{Reproducer:} the crashing input (seed) suitable for deterministic replay;
  \item \textbf{Harness metadata:} target native function, app-specific call sequence, and inferred argument constraints;
  \item \textbf{Fuzzing metadata:} iterations/coverage counters from the underlying engine.
\end{itemize}
POIROT operates without access to native source code and does not require manual harness engineering \cite{poirot-usenix25}.

\section{Scale of evaluation (for context).}
In its evaluation, POIROT analysed the 3{,}967 most popular Android apps that bundle native libraries, reporting 4{,}282 \emph{unique} crashes affecting 934 apps; multiple issues were confirmed as vulnerabilities \cite{poirot-usenix25}. We refer to this corpus as the canonical benchmark when discussing expected crash profiles and artefact structure.

\section{Assumptions and limitations.}
POIROT’s harnesses are derived from static analysis of managed code and may miss hidden initialisation or implicit invariants; this can lead to infeasible call sequences or under-approximation of constraints. Some crashes depend on environment-specific state or non-determinism and may not be fully reproducible outside POIROT’s testbed. Finally, obfuscation, stripped symbols, and complex reflection patterns can reduce the fidelity of usage recovery; our triager explicitly surfaces such uncertainty when assigning confidence.

\section{Interface used in this thesis.}
We treat POIROT as an oracle that provides: (i) crash reports, (ii) reproducers, and (iii) harness/usage metadata. These artefacts are consumed by our tool-grounded \gls{llm} triager in later chapters; no modifications to POIROT are required on our side.


\noindent\textcolor{red}{===============================================================}
\end{comment}

This thesis relies on crash data generated by fuzzing Android native libraries embedded in \glspl{apk} via the \gls{jni}. To obtain these data, \emph{POIROT}, an automated framework for app-specific harness synthesis and large-scale fuzzing of native libraries on Android \cite{poirot-usenix25}, was employed. Reproducibility is ensured by adoption of the authors’ artifact (Docker-based environment and emulator setup) \cite{poirot-usenix25-appendix}. POIROT-generated crash artefacts provide the input to the \gls{llm}-based triage system.

\section{Data generation via POIROT}

POIROT follows a three-stage process.\\
\begin{myenumerate}[label=\Roman*.]
    \item \textbf{Static analysis.} The framework extracts \gls{dex} bytecode and native libraries from each \gls{apk} and runs two scalable analyses over the Java side: a \emph{call-sequence analysis} to recover app-specific invocation sequences of native APIs, and an \emph{argument analysis} to infer lightweight constraints for parameters (e.g., array-length relations, file-path uses).% These results tailor fuzzing to how the consumer app actually exercises the library.
    \item \textbf{Harness synthesis.} From those analyses, POIROT synthesises per-function drivers that (a) construct a minimal \gls{art}-backed runtime with a genuine \texttt{JNIEnv} to support bidirectional callbacks and (b) encode the recovered call sequence and parameter constraints. %The harness maps fuzzer bytes to Java types (primitive types, strings, byte arrays/buffers) and forwards intermediate results between calls when types match.
    \item \textbf{Fuzzing and crash detection.} Harnesses are executed under greybox fuzzing (AFL++ with Frida-based instrumentation), collecting coverage and detecting memory-safety faults. Crashes are deduplicated and recorded together with backtraces and minimal reproducers; allocator/sanitiser diagnostics (e.g., Scudo signals, ASan/HWASan when available) assist categorisation.% \cite{poirot-usenix25}.
\end{myenumerate}





\section{Dataset produced for this thesis}

The dataset used for this triager consists of deduplicated \emph{crash reports} emitted by POIROT, while fuzzing native C/C++ code reachable from each \gls{apk} through the \gls{jni}. For each crash, the stack trace is retained. This artifact is cross-referenced with triage based on LLM to reconstruct and analyze the path and provide an evidence-based assessment, by retrieving the necessary information.\\


\noindent Listing~\ref{lst:POIROT-output} shows two representative crashes produced when fuzzing the method\\ \texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo} in the application\\ \texttt{com.tplink.skylight}. In both cases, the top frames reveal an allocator abort in Scudo (\texttt{scudo::reportInvalidChunkState} $\rightarrow$ \texttt{scudo::Allocator\ldots::deallocate}) followed by the target media routines (\texttt{mp4\_write\_one\_h264} / \texttt{mp4\_write\_one\_jpeg}) and the JNI bridge function (\texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo}). Operationally, this pattern indicates that the runtime detected an invalid deallocation (e.g., double/invalid free) during processing of fuzzer-supplied data, and surfaced it as an immediate \texttt{abort}. 

Each POIROT crash record stores the full stack trace (as shown in Listing~\ref{lst:POIROT-output}), from which it is possible to extract the native function name, the JNI entry point, and the likely cause of the crash.

Each method crash is stored in its own file within a unique directory named with the corresponding method. The \textit{Triage} section\footnote{\url{https://github.com/HexHive/droidot/\#triage}} of the GitHub README provides an example of the directory structure used for a crash.
%From a data perspective, each POIROT crash record stores: (i) the full stack trace (as in the listing), (ii) the native symbol or offset for the site nearest to the failure, (iii) the JNI entry point and the managed call sequence used by the harness, and (iv) the minimised input that reproduces the failure \cite{poirot-usenix25,poirot-usenix25-appendix}. \textcolor{red}{DA CONTROLLARE}

\vfill

\begin{lstlisting}[caption={folder2backtraces.txt file, created as the output of POIROT, for the apk \texttt{com.tplink.skylight} in the function \texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo} }, label={lst:POIROT-output}]
################ CRASH NR 0 ######################
abort 
scudo::die
scudo::ScopedErrorReport::~ScopedErrorReport
scudo::reportInvalidChunkState
scudo::Allocator<scudo::AndroidConfig, &scudo_malloc_postinit>::deallocate
mp4_write_one_h264 
Java_com_tplink_skylight_common_jni_MP4Encoder_packVideo 
fuzz_one_input 
main 
###################################################
################ CRASH NR 1 ######################
abort 
scudo::die
scudo::ScopedErrorReport::~ScopedErrorReport
scudo::reportInvalidChunkState
scudo::Allocator<scudo::AndroidConfig, &scudo_malloc_postinit>::deallocate
mp4_write_one_jpeg 
Java_com_tplink_skylight_common_jni_MP4Encoder_packVideo 
fuzz_one_input 
main 
###################################################
\end{lstlisting}


\subsection*{Environment}
\label{chp:preliminaries_env}

\textcolor{red}{Non so se posso lasciarlo, per descrivere passo passo il procedimento, o lasciar solo la parte sotto con AWS}
The approach was initially validated locally by running POIROT in Docker on a workstation and executing targets on a physical Android device (Google Pixel~9).  
Since the number of \glspl{apk} to process exceeded the capacity of a single device, the data-generation phase was subsequently migrated to a cloud host.


%The pipeline was first validated locally by running POIROT in Docker on a workstation and executing targets on a physical Android device (Google Pixel~9). Because the number of \glspl{apk} to process exceeded the capacity of a single device, the data-generation step was migrated to a cloud host. 

Concretely, \gls{aws} \gls{ec2} was used with an ARM-based Graviton instance to match the target \texttt{ARM64-v8a} ABI of the native libraries. The host was a \texttt{c6g.metal} machine (64~vCPU, 128~GB RAM), which provides an ARM (AArch64) host and hardware virtualisation via KVM. This configuration allows the Android emulator to run ARM system images directly on an ARM host, avoiding cross-ISA translation and enabling faithful execution.

POIROT’s analyses and harness synthesis ran inside the provided Docker environment; fuzzing then executed on the emulator farm on the \texttt{c6g.metal} host. The setup produced the same crash artefacts as the local pilot (stack traces, reproducer inputs, managed–native call sequences), but with larger scale.

\begin{comment}
    

\section{Terminology and notation}

We use the following terms consistently:
\textbf{Seed/test case} — an input byte string consumed by the harness; mutated during fuzzing.
\textbf{Coverage} — edge/BB coverage collected from the target library while executing the last call in the synthesised sequence.
\textbf{Harness} — a driver that initialises a minimal \gls{art}+\texttt{JNIEnv} and invokes the app-specific native call sequence with mapped arguments.
\textbf{Crash} — an abnormal termination (e.g., allocator abort, SIGSEGV) with a reproducer, backtrace, and diagnostics.
\textbf{Deduplication} — bucketing crashes by signal/address/top frames (or tool-defined hashes) to remove near-duplicates.
\textbf{Crash triage} — post-fuzzing analysis to decide whether a crash indicates a likely vulnerability, its class/severity, and evidence.

\paragraph{Scope.} The remainder of the thesis exclusively analyses crashes originating from native C/C++ libraries invoked through \gls{jni}; pure Java/Kotlin defects are out of scope. The Preliminaries above define how the data are obtained and packaged before our \gls{llm}-based triage is applied.
\end{comment}