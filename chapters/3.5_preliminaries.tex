\chapter{Preliminaries}
\label{chp:preliminaries}

\section{POIROT}

\begin{comment}
    \section{Goal and setting.}
\emph{POIROT} targets commercial Android applications that embed native C/C++ libraries invoked through the \gls{jni}. Its goal is to discover security-relevant defects by \emph{automatically} building a realistic, consumer-specific fuzzing harness that mirrors how the app actually exercises its native library, and then running coverage-guided fuzzing at scale \cite{poirot-usenix25}.

\section{Key idea.}
Instead of relying on generic, library-centric drivers, POIROT recovers the \emph{app’s} usage of the library from Dalvik bytecode and synthesises a harness that supports \emph{bidirectional} \gls{jni} interactions. The harness initialises app-relevant state, invokes native entry points following app-specific call sequences, and preserves argument/value constraints discovered in the managed code, thereby increasing the likelihood of reaching security-critical behaviours during fuzzing \cite{poirot-usenix25}.

\section{Inputs and outputs.}
Given an APK and its embedded native libraries, POIROT:
\begin{enumerate}
  \item analyses \gls{dex} to extract \emph{consumer usage}: call sites to native methods, inter-procedural call sequences, and salient argument/value flows across the \gls{jni} boundary;
  \item synthesises a consumer-specific harness that loads the target library and replays realistic \gls{jni} interactions;
  \item executes a coverage-guided fuzzing campaign on Android virtual devices and records crashes.
\end{enumerate}
For each crash, POIROT emits artefacts used later by our triager:
\begin{itemize}
  \item \textbf{Crash report:} signal or sanitizer class, faulting address/PC, and (where available) backtrace;
  \item \textbf{Reproducer:} the crashing input (seed) suitable for deterministic replay;
  \item \textbf{Harness metadata:} target native function, app-specific call sequence, and inferred argument constraints;
  \item \textbf{Fuzzing metadata:} iterations/coverage counters from the underlying engine.
\end{itemize}
POIROT operates without access to native source code and does not require manual harness engineering \cite{poirot-usenix25}.

\section{Scale of evaluation (for context).}
In its evaluation, POIROT analysed the 3{,}967 most popular Android apps that bundle native libraries, reporting 4{,}282 \emph{unique} crashes affecting 934 apps; multiple issues were confirmed as vulnerabilities \cite{poirot-usenix25}. We refer to this corpus as the canonical benchmark when discussing expected crash profiles and artefact structure.

\section{Assumptions and limitations.}
POIROT’s harnesses are derived from static analysis of managed code and may miss hidden initialisation or implicit invariants; this can lead to infeasible call sequences or under-approximation of constraints. Some crashes depend on environment-specific state or non-determinism and may not be fully reproducible outside POIROT’s testbed. Finally, obfuscation, stripped symbols, and complex reflection patterns can reduce the fidelity of usage recovery; our triager explicitly surfaces such uncertainty when assigning confidence.

\section{Interface used in this thesis.}
We treat POIROT as an oracle that provides: (i) crash reports, (ii) reproducers, and (iii) harness/usage metadata. These artefacts are consumed by our tool-grounded \gls{llm} triager in later chapters; no modifications to POIROT are required on our side.


\noindent\textcolor{red}{===============================================================}
\end{comment}

This thesis relies on crash data generated by fuzzing Android native libraries embedded in \glspl{apk} via the \gls{jni}. To obtain these data, we employ \emph{POIROT}, an automated framework for app-specific harness synthesis and large-scale fuzzing of native libraries on Android \cite{poirot-usenix25}. We also use the authors’ artifact (Docker-based environment and emulator setup) to ensure reproducibility of the data-generation pipeline \cite{poirot-usenix25-appendix}. The crash artefacts produced by POIROT constitute the input to our \gls{llm}-based triage system.

\section{Data generation via POIROT}

POIROT follows a three-stage process \cite{poirot-usenix25}.\\
\textbf{(i) Static analysis.} The framework extracts \gls{dex} bytecode and native libraries from each \gls{apk} and runs two scalable analyses over the Java side: a \emph{call-sequence analysis} to recover app-specific invocation sequences of native APIs, and an \emph{argument analysis} to infer lightweight constraints for parameters (e.g., array-length relations, file-path uses). These results tailor fuzzing to how the consumer app actually exercises the library.\\
\textbf{(ii) Harness synthesis.} From those analyses, POIROT synthesises per-function drivers that (a) construct a minimal \gls{art}-backed runtime with a genuine \texttt{JNIEnv} to support bidirectional callbacks and (b) encode the recovered call sequence and parameter constraints. The harness maps fuzzer bytes to Java types (primitive types, strings, byte arrays/buffers) and forwards intermediate results between calls when types match.\\
\textbf{(iii) Fuzzing and crash detection.} Harnesses are executed under greybox fuzzing (AFL++ with Frida-based instrumentation), collecting coverage and detecting memory-safety faults. Crashes are deduplicated and recorded together with backtraces and minimal reproducers; allocator/sanitiser diagnostics (e.g., Scudo signals, \gls{asan}/\gls{hwasan} when available) assist categorisation \cite{poirot-usenix25}.

\section{Dataset produced for this thesis}

The dataset used for our triager consists of deduplicated \emph{crash reports} emitted by POIROT while fuzzing native C/C++ code reachable from each \gls{apk} through the \gls{jni}. For every unique crash, we retain the stack trace and the call sequence of the \gls{apk}. These artefacts are later cross-referenced by the \gls{llm}-based triage to reconstruct the failing path and to anchor judgements with concrete evidence (e.g., specific frames, function names, or short decompiled snippets).

Listing~\ref{lst:POIROT-output} shows two representative crashes produced when fuzzing the method\\ \texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo} in the application\\ \texttt{com.tplink.skylight}. In both cases, the top frames reveal an allocator abort in Scudo (\texttt{scudo::reportInvalidChunkState} $\rightarrow$ \texttt{scudo::Allocator\ldots::deallocate}) followed by the target media routines (\texttt{mp4\_write\_one\_h264} / \texttt{mp4\_write\_one\_jpeg}) and the JNI bridge function (\texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo}). Operationally, this pattern indicates that the runtime detected an invalid deallocation (e.g., corrupted metadata or a double/invalid free) during processing of fuzzer-supplied data, and surfaced it as an immediate \texttt{abort}. 

From a data perspective, each POIROT crash record stores: (i) the full stack trace (as in the listing), (ii) the native symbol or offset for the site nearest to the failure, (iii) the JNI entry point and the managed call sequence used by the harness, and (iv) the minimised input that reproduces the failure \cite{poirot-usenix25,poirot-usenix25-appendix}.

\begin{lstlisting}[caption={Output of POIROT of apk \texttt{com.tplink.skylight} in the function \texttt{Java\_com\_tplink\_skylight\_common\_jni\_MP4Encoder\_packVideo} }, label={lst:POIROT-output}]
################ CRASH NR 0 ######################
abort 
scudo::die
scudo::ScopedErrorReport::~ScopedErrorReport
scudo::reportInvalidChunkState
scudo::Allocator<scudo::AndroidConfig, &scudo_malloc_postinit>::deallocate
mp4_write_one_h264 
Java_com_tplink_skylight_common_jni_MP4Encoder_packVideo 
fuzz_one_input 
main 
###################################################
################ CRASH NR 1 ######################
abort 
scudo::die
scudo::ScopedErrorReport::~ScopedErrorReport
scudo::reportInvalidChunkState
scudo::Allocator<scudo::AndroidConfig, &scudo_malloc_postinit>::deallocate
mp4_write_one_jpeg 
Java_com_tplink_skylight_common_jni_MP4Encoder_packVideo 
fuzz_one_input 
main 
###################################################
\end{lstlisting}


\section{Environment}

We first validated the pipeline locally by running POIROT in Docker on a workstation and executing targets on a physical Android device (Google Pixel~9). Because the number of \glspl{apk} to process was too large for a single device, we migrated the data-generation step to a cloud host.

Concretely, we used \gls{aws} \gls{ec2} with an ARM-based Graviton instance to match the target \texttt{ARM64-v8a} ABI of the native libraries. The host was a \texttt{c6g.metal} machine (64~vCPU, 128~GB RAM), which provides an ARM (AArch64) host and hardware virtualisation via \gls{kvm}. This configuration lets the Android emulator run ARM system images directly on an ARM host, avoiding cross-ISA translation and enabling faithful execution of native code compiled for ARM CPUs (as in typical Snapdragon/Exynos/MediaTek devices).

POIROT’s analyses and harness synthesis ran inside the provided Docker environment; fuzzing then executed on the emulator farm on the \texttt{c6g.metal} host. The setup produced the same crash artefacts as our local pilot (stack traces, reproducer inputs, managed–native call sequences), but with larger scale.

\begin{comment}
    

\section{Terminology and notation}

We use the following terms consistently:
\textbf{Seed/test case} — an input byte string consumed by the harness; mutated during fuzzing.
\textbf{Coverage} — edge/BB coverage collected from the target library while executing the last call in the synthesised sequence.
\textbf{Harness} — a driver that initialises a minimal \gls{art}+\texttt{JNIEnv} and invokes the app-specific native call sequence with mapped arguments.
\textbf{Crash} — an abnormal termination (e.g., allocator abort, SIGSEGV) with a reproducer, backtrace, and diagnostics.
\textbf{Deduplication} — bucketing crashes by signal/address/top frames (or tool-defined hashes) to remove near-duplicates.
\textbf{Crash triage} — post-fuzzing analysis to decide whether a crash indicates a likely vulnerability, its class/severity, and evidence.

\paragraph{Scope.} The remainder of the thesis exclusively analyses crashes originating from native C/C++ libraries invoked through \gls{jni}; pure Java/Kotlin defects are out of scope. The Preliminaries above define how the data are obtained and packaged before our \gls{llm}-based triage is applied.
\end{comment}