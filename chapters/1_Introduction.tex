%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chp:intro}

Android powers most of the world's smartphones (with around a 75\% market share), shaping a vast, heterogeneous ecosystem of devices, vendors, and software variants \cite{statcounter-android-2025,acar-sp16}. 

At this scale, with a marketplace hosting millions of apps and extensive reuse of the same third-party libraries across thousands of packages.%, the central security challenge is one of quantity. 
A single vulnerable native component can propagate widely.

Despite Android’s multi-layered security model, which includes application sandboxing, permission mediation, SEAndroid/SELinux policy, and verified boot, vulnerabilities persist across apps, frameworks, and vendor components \cite{acar-sp16,mayrhofer-apsm-2023}. High-impact examples include memory-safety vulnerabilities in media codecs, that have enabled fully remote, zero-interaction compromise of commercial devices delivered via MMS \cite{p0-qmage}. 
Furthermore, empirical evidence indicates that popular apps often embed third-party components with known \glsxtrshortpl{cve} and that patch adoption on the app side often lags behind fixes to upstream libraries \cite{almanee-icse21}.

Within this landscape, many Android applications embed native C/C++ libraries to achieve low latency, reuse existing code, or access device- and vendor-specific functionality. These libraries are invoked across the \glsxtrshort{jni} boundary, which bridges managed code and native components. While effective for performance, this practice imports the memory-unsafe semantics of C/C++ into an otherwise memory-safe application model, increasing the likelihood of buffer overflows, use-after-free, and related memory-corruption defects. Because native code executes in the same process as the \glsxtrshort{art}, a flaw in the native layer can compromise the entire app and its data, irrespective of the safety of its Java/Kotlin components \cite{almanee-icse21, mergendahl-ndss22}.

\textcolor{blue}{"non puoi introdurre il fuzzing così velocemente. Passi dal discorso generale di vulnerabilità lato nativo e poi, diretto, all'uso di fuzzing"}

\textcolor{red}{A common approach to uncover software defects at scale is fuzzing, an automated dynamic testing technique that feeds programs with large volumes of unexpected, invalid, or mutated inputs to trigger abnormal behaviours. By exercising a wide range of execution paths, fuzzing reveals crashes that may indicate underlying vulnerabilities.}

Recent works automate the generation of harnesses and large-scale fuzzing for Android native libraries. Tools such as POIROT can synthesise app-specific harnesses that support bidirectional \glsxtrshort{jni} interactions and then fuzz them at scale, reporting thousands of distinct crashes and confirmed vulnerabilities \cite{poirot-usenix25}. 
However, triaging the resulting crashes, separating benign faults from security-relevant memory errors, remains largely manual.

%; existing bucketing and “exploitability” heuristics have limited precision and still require substantial analyst oversight \cite{}.

This thesis investigates whether a tool-grounded \gls{llm} can reduce manual effort and improve consistency in crash triage for Android native libraries. To this end, it introduces an architecture\footnote{Implementation available at \url{https://github.com/Nicola-01/LLM-Triaging}.} in which POIROT causes crashes; an \gls{llm}-based triager consumes the associated reports and augments them with program context via the \gls{mcp}, invoking reverse-engineering tools (Jadx for Dalvik/bytecode and manifest, and Ghidra for native disassembly/decompilation) to recover stack evidence, function names, and short decompiled snippets.
The triager classifies whether a crash likely indicates a vulnerability, explains the rationale in plain terms, provides a severity estimate anchored to standard taxonomies/scores (\glsxtrshort{cwe}/\glsxtrshort{cvss}), and suggests follow-up actions. % (\gls{cwe}/\gls{cve}/\gls{cvss}) % forse no cve