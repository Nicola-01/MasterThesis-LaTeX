%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chp:intro}

Android underpins the majority of smartphones worldwide (around 75\% market share), shaping a vast, heterogeneous ecosystem of devices, vendors, and software variants \cite{statcounter-android-2025,acar-sp16}. This scale and diversity amplify both the \emph{benefits} of an appified distribution model and the \emph{security} challenges that follow from fragmented update paths and complex supply chains \cite{acar-sp16,mayrhofer-apsm-2023}.

Despite Android’s multi-layered security model (application sandboxing, permission mediation, \mbox{SEAndroid}/SELinux policy, verified boot), vulnerabilities persist across app, framework, and vendor components \cite{mayrhofer-apsm-2023,acar-sp16}. High-impact cases have included memory-safety flaws in media codecs enabling remote, interactionless compromise via MMS on commercial devices \cite{p0-qmage}. Empirical evidence further indicates that popular apps frequently embed third-party components with known \gls{cve}s, and that patch adoption on the app side often lags upstream library fixes \cite{almanee-icse21}.

Within this landscape, many Android applications embed native C/C++ libraries to achieve low latency, reuse existing code, or access device- and vendor-specific functionality. These libraries are invoked across the \gls{jni} boundary, which bridges managed code and native components. While effective for performance, this practice imports the memory-unsafe semantics of C/C++ into an otherwise memory-safe application model, increasing the likelihood of buffer overflows, use-after-free, and related memory-corruption defects. Because native code executes in the same process as the \gls{art}, a flaw in the native layer can compromise the entire app and its data, irrespective of the safety of its Java/Kotlin components \cite{almanee-icse21, mergendahl-ndss22}.

Recent work automates harness generation and large-scale fuzzing for Android native libraries. Systems such as POIROT synthesise app-specific harnesses that support bidirectional \gls{jni} interactions and then fuzz them at scale, reporting thousands of distinct crashes and confirmed vulnerabilities \cite{poirot-usenix25}. Earlier approaches mostly relied on generic, library-centric fuzzing with consumer-agnostic harnesses \cite{utopia-sp23, fuzzgen-usenix20}, while only a few model app-specific usage on Android \cite{atlas-issta24}. However, triaging the resulting crashes, separating benign faults from security-relevant memory errors, remains largely manual; existing bucketing and “exploitability” heuristics have limited precision and still require substantial analyst oversight \cite{scb-ase18,igor-ccs21}.

This thesis investigates whether a tool-grounded \gls{llm} can reduce manual effort and improve consistency in crash triage for Android native libraries. We propose an architecture in which POIROT produces crashes; an \gls{llm}-based triager consumes the associated reports and augments them with program context via the \gls{mcp}, invoking reverse-engineering tools (Jadx for Dalvik/bytecode and manifest, and Ghidra for native disassembly/decompilation) to recover stack evidence, function names, and short decompiled snippets. The triager classifies whether a crash likely indicates a vulnerability, explains the rationale in plain terms, provides a severity estimate anchored to standard taxonomies/scores (\gls{cwe}/\gls{cve}/\gls{cvss}), and suggests follow-up actions.