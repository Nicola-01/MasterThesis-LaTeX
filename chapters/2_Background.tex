\chapter{Background}
\label{chp:backgroud}

\section{Android Native}
Android itself relies extensively on native C/C++ libraries within its core architecture. Many system components and services, such as the runtime, media stack, graphics pipeline, and hardware abstraction layer (HAL), are implemented in native code for reasons of performance, portability, and direct hardware access \cite{android-platform}. The framework exposes parts of this functionality to applications through Java/Kotlin \glspl{api}, enabling managed code to invoke native system services when needed. 

At the system level, Android’s C standard library and dynamic linker are provided by \emph{Bionic}, a lightweight libc/libm/libdl implementation optimised for mobile environments \cite{bionic-maint}. This design allows the platform to combine managed execution (via the \gls{art}) with efficient, low-level components responsible for performance-critical and hardware-dependent operations. Figure~\ref{fig:androidStack} illustrates the Android platform architecture, highlighting how native libraries underpin the runtime, system services, and the HAL.

Beyond the platform itself, developers can extend Android apps with their own native code through the \gls{ndk}.

The advantages of native development stem from the ability to execute compiled machine code directly on the target CPU, allowing finer-grained optimisation and efficient memory use, important for resource-constrained mobile devices. It also enables hardware acceleration and access to specialised APIs (e.g., GPU, DSP, or sensor interfaces), making it indispensable in areas like augmented or virtual reality, game engines (e.g., Unity, Unreal), and device-specific system utilities. \textcolor{red}{Dovrei cercare una citazione}

However, using native code extends the scope of Android applications beyond the safety of the managed runtime. Developers must explicitly handle memory allocation and deallocation, thread synchronisation, and exception propagation, as these are not automatically managed by the \gls{art}. Cross-ABI compatibility, debugging complexity, and maintenance across Android versions further increase the development burden. Consequently, the \gls{ndk} is recommended only when its benefits outweigh these costs \cite{android-ndk-getting-started,android-ndk-concepts,jni-tips}.

This capability of use native code, extends the reach of Android apps beyond the managed runtime but also introduces explicit responsibilities for developers. Native code must handle its own memory management, threading and exception handling. This is significantly different from pure Java/Kotlin development.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \def\W{8cm}
        \def\Wleft{4.46cm}
        \def\Wright{3.47cm}
        
        \node[layer, fill=cSystem!60, minimum width=\W] (apps) {System Apps};
        \node[layer, fill=cJava!60, minimum width=\W, below=0.5mm of apps] (java) {Java API Framework};
        \node[layer, fill=cNative!60, minimum width=\Wleft, below=0.5mm of java, anchor=west] (native) at ($(java.south west)+(0,-3.5mm)$) {Native C/C++ Libraries};
        \node[layer, fill=cRuntime!70, minimum width=\Wright, below=0.5mm of java, anchor=east] (runtime) at ($(java.south east)+(0,-3.5mm)$) {Android Runtime};
        \node[layer, fill=cHAL!60, minimum width=\W, below=8mm of java] (hal) {Hardware Abstraction Layer (HAL)};
        \node[layer, fill=cKernel!60, minimum width=\W, below=0.5mm of hal] (kernel) {Linux Kernel};
    \end{tikzpicture}
    \caption{Android software stack. }
    \label{fig:androidStack}
\end{figure}

\subsection{\glsxtrlong{ndk}}
The \gls{ndk} is a collection of tools, headers, and libraries that enable developers to embed C and C++ code within Android applications and interact natively with hardware, sensors, and system \glspl{api} \cite{android-ndk-getting-started}. The \gls{ndk} supports compilation into shared (and static) libraries that can be packaged inside the \gls{apk}, and offers native interfaces for tasks such as sensor input, asset loading, and more \cite{android-ndk-concepts}.

Developers typically adopt native code for three main reasons:
\begin{itemize}
  \item \textbf{Performance optimization:} achieving low-latency processing in compute-intensive domains such as graphics, signal processing, physics, or cryptography.
  \item \textbf{Library reuse:} integrating existing C/C++ libraries (e.g.\ cryptography, compression, codecs) to avoid rewriting functionality in Java/Kotlin.
  \item \textbf{Hardware or vendor-specific access:} interacting directly with low-level or proprietary \glspl{api} (e.g.\ custom sensors, specialized accelerators) not exposed in the Java framework.
\end{itemize}

However, using the \gls{ndk} comes with tradeoffs. Native development adds complexity in build configuration, cross-ABI support, debugging, and maintenance across Android versions. Not all Android \glspl{api} are directly available through the \gls{ndk}, so bridging via \gls{jni} is often required for broad framework functionality \cite{android-ndk-concepts}. 

\subsection{\glsxtrlong{jni}}
The \gls{jni} (Java Native Interface) is a native programming interface that enables Java or Kotlin code running in a virtual machine to interoperate with libraries and applications written in C/C++ \cite{jni-spec-design,jni-spec-intro}. It allows managed code to call into native code, and for native code to call back into the \gls{vm}, manipulate Java objects, throw exceptions, and more. The \gls{jni} is designed to impose no restrictions on the implementation of the \gls{vm}, thereby preserving binary compatibility across \gls{vm} vendors \cite{jni-spec-intro}.  

Listing~\ref{lst:javaNative} shows a Java class declaring a \texttt{native} method, while Listing~\ref{lst:JNI} gives the corresponding C implementation on the native side.

\begin{lstlisting}[language=Java+JNI, caption={Java class declaring a \texttt{native} method}, label={lst:javaNative}] 
public class foo {
    private native double bar(int i, String s);
    
    static {
        System.loadLibrary("native-lib");
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C+JNI, caption={Native implementation of \texttt{bar}}, label={lst:JNI}]
jdouble Java_pkg_foo_bar(JNIEnv *env,   // ptr to JNI interface
                         jobject obj,   // "this" pointer
                         jint i,        // first "real" parameter
                         jstring s)     // second "real" parameter
{
    /* Method implementation */
    return 0.0;
}
\end{lstlisting}


\subsection{Vulnerabilities and Impact on the Android Sandbox}
Native memory-safety bugs remain the dominant path to serious compromise on Android. Although the platform’s sandbox assigns each app a distinct UID and constrains it further with SELinux policies, a native component compromised inside that boundary still runs with the app’s privileges and can expose any secrets or capabilities already permitted (e.g., tokens, stored content, or keys) \cite{android-app-sandbox,android-selinux}. In practice, this turns local corruption into high-impact data access or control-flow hijacking even without crossing process boundaries.

Attackers often amplify impact by chaining flaws across interfaces. Many system services are native and reachable over Binder; memory corruption in such a service can be triggered via IPC by a malicious client to escape app-level limits \cite{mao-nass-usenix25}. Within the same process, unsafe native–Java bridges (JNI, shared memory) or misuse of memory-protection syscalls (e.g., \texttt{mprotect}) can subvert runtime invariants, enabling code injection or manipulation of JIT/class metadata \cite{going-native-ndss17}. A further, pragmatic risk is “patch latency”: empirical studies show popular apps frequently ship outdated third-party native libraries with known CVEs for months to years, leaving well-documented bugs exploitable long after fixes exist \cite{almanee-icse21}. 

Mitigation requires defense-in-depth: modern Android hardening (ASLR/DEP, control-flow integrity, memory tagging), combined with strict interface design and timely library updates, can substantially raise exploitation cost even when bugs persist \cite{android-ndk-mte}. 


\begin{comment}
    \subsection{Vulnerabilities and Impact on the Android Sandbox}
Memory-safety defects in native libraries—such as buffer overflows, out-of-bounds reads/writes, use-after-free, and double free—belong to well-known categories captured by \gls{cwe}, and they frequently appear in \gls{cve} records \cite{cwe-mitre,cve-overview}. On Android, these errors may manifest as application crashes, or in more severe cases permit arbitrary code execution or data tampering, depending on mitigations and exploitability assumptions \cite{android-native-risk}.  

Because native code runs within the same process as managed Java/Kotlin code, a compromised native component can escalate local access to high-impact asset access. The Android sandbox enforces per-\gls{uid} isolation at the kernel level, reinforced by SELinux policies, thereby limiting the immediate blast radius to resources the app is permitted to access \cite{android-app-sandbox,android-selinux,apsm-mayrhofer-2023}. Nonetheless, real-world applications often bundle sensitive data (e.g. authentication tokens, stored user content, cryptographic keys) that fall precisely within those permissions, meaning native compromise can directly expose high-value artifacts.  

In practice, attackers can chain native vulnerabilities with other flaws or system interfaces to amplify impact. For example, many Android system services are implemented in native C/C++ and expose Binder or RPC interfaces; memory corruption in such a service can be triggered via IPC by a malicious app to escalate privileges beyond app-level constraints \cite{mao-nass-usenix25}. In other scenarios, native code may corrupt memory pages shared with the managed runtime (e.g. altering JIT or class metadata) by transgressing memory protection via system calls (e.g. \texttt{mprotect}), thus undermining Java-level safety invariants and enabling code injection or VM subversion \cite{going-native-ndss17}. Another common vector is outdated third-party native libraries: empirical studies show that a significant fraction of popular apps ship unpatched vulnerable native libraries, and that developers take on average hundreds of days to apply upstream patches \cite{almanee-icse21}. This “patch latency” enables attackers to exploit known vulnerabilities even in apps that seem benign at the Java layer.  

Further, native vulnerabilities may play a role in sandbox bypass when native–Java communication channels (e.g. JNI calls, shared memory, or custom bridging interfaces) are too permissive, enabling the attacker to pivot across boundaries. And, although less common, sophisticated combos of memory bugs and hardware or side-channel attacks (such as cache timing, fault injection, or speculative execution vulnerabilities) may escalate privileges beyond process boundaries or extract secrets not otherwise exposed \cite{munoz2024cracking}. To mitigate these risks, secure design and runtime hardening (e.g. ASLR, DEP, bounds sanitizers, control-flow integrity) are essential in containing exploitation even within a sandboxed environment.

Memory-safety defects in native libraries—such as buffer overflows, out-of-bounds reads or writes, use-after-free, and double free—are widespread in C/C++ code and constitute classic weakness families in \gls{cwe} taxonomies. For example, buffer overflows occur when a program writes more data than a destination buffer can hold, thereby overwriting adjacent memory (heap or stack) in the process \cite{cwe-123,buffer-overflow-wiki}. Use-after-free (CWE-416) arises when memory is accessed after it has been freed, causing references to dangling pointers to lead to memory corruption or code execution \cite{cwe-416}. Double free (CWE-415) refers to freeing the same memory region twice, which may corrupt allocator metadata, lead to memory management inconsistencies, and enable exploitation such as write-what-where conditions \cite{cwe-415,owasp-doublefree}.  

On Android, such defects may lead to denial-of-service (e.g. crash) or escalate to arbitrary code execution depending on available mitigations (ASLR, DEP, control-flow integrity) and the exploitability context \cite{android-native-risk,android-ndk-mte}. Because native code executes within the same process as the managed layer, a corrupted native component may corrupt or hijack data, control flow, or even the Java runtime itself, effectively breaking the isolation guaranteed by the managed environment.  

\end{comment}

%\subsection{Security and diagnostics (brief)}
%Because native code shares the app process, memory-safety bugs (e.g., buffer overflows, out-of-bounds access, use-after-free) can compromise integrity and confidentiality. During testing, enable sanitizers where feasible: \gls{asan} for detailed heap/stack diagnostics and \gls{hwasan} to catch temporal errors with lower overhead on ARMv8.5+ devices. These tools materially improve native defect detection during fuzzing and CI \cite{asan-aosp,hwasan-ndk}.

\section{Fuzzing}
\section{\glsxtrlong{llm}}
\subsection{\glsxtrlong{mcp}}
\section{Classification}

\section{Memory safety differences and vulnerability classes}
Java/Kotlin provide memory safety by construction (bounds checks, GC), whereas C/C++ delegate memory and lifetime management to the programmer, enabling classes of bugs that frequently underlie security vulnerabilities. Common weakness families include buffer overflow/underflow, use-after-free, out-of-bounds read/write, and double free; these are captured in \gls{cwe} and repeatedly observed in \gls{cve} records \cite{cwe-mitre,cve-overview}. On Android, such defects can lead to denial of service (crash) or arbitrary code execution, depending on mitigations and exploitability \cite{android-native-risk}.



\section{Fuzzing native libraries and harness generation}
Coverage-guided fuzzing mutates inputs to maximise code coverage while detecting crashes via sanitizers or OS signals. \gls{aflpp} generalises AFL’s greybox approach and incorporates state-of-the-art features (e.g., custom mutators) for broad applicability \cite{aflpp-woot20}. \gls{libfuzzer} integrates tightly with LLVM sanitizers and is widely used for in-process targets \cite{libfuzzer-llvm}. Sanitizers such as \gls{asan} and \gls{hwasan} are available on Android and provide precise diagnostics for memory-safety violations \cite{asan-android-aosp,hwasan-ndk}.

The limiting factor for library fuzzing is the harness: an executable environment that exercises target \glspl{api} with realistic sequences and well-formed objects. Automating harness synthesis for Android native libraries is challenging due to cross-language interactions, complex object lifecycles, and the need to emulate app-specific call sequences via \gls{jni}. POIROT addresses these challenges by statically analysing an app’s Java-side usage of the native library, synthesising a consumer-specific harness that supports bidirectional \gls{jni}, and running large-scale fuzzing campaigns \cite{poirot-usenix25}. Prior works on harness generation and Android library fuzzing (e.g., ATLAS, FuzzGen) highlight the broader landscape and the difficulty of scaling without app-specific context \cite{atlas-issta24,fuzzgen-usenix20}.

\section{Crash triage: principles and challenges}
Crash triage seeks to (i) deduplicate and bucket crashes, (ii) decide whether a crash indicates a security-relevant vulnerability, and (iii) prioritise fixes. Heuristic exploitability assessors and semantic crash bucketing methods have been proposed to improve accuracy and scalability, yet they typically assume desktop/server contexts and still require expert review \cite{scb-ase18,igor-ccs21}. On Android, crashes often originate in native code called through \gls{jni} and may depend on app-specific object invariants; reproducing and interpreting them benefits from reverse-engineering and sanitizer evidence \cite{poirot-usenix25,asan-android-aosp}.

\section{\gls{llm}s with tool grounding for security triage}
Emerging studies suggest that \gls{llm}s can assist in vulnerability management tasks such as \gls{cwe} classification and severity estimation. For instance, CASEY reports non-trivial accuracy for \gls{cwe} and severity identification on proprietary datasets, indicating potential to streamline triage workflows \cite{casey-aic25}. LProtector explores \gls{llm}-driven detection pipelines that combine static/dynamic signals with model judgements \cite{lprotector-2024}. However, unguided \gls{llm}s may hallucinate or misinterpret low-level details. Tool grounding mitigates this risk by connecting the model to program artefacts through \gls{mcp}, enabling retrieval of Jadx bytecode contexts, Android manifests, and Ghidra decompilation/disassembly snippets that can be quoted as evidence in triage outputs \cite{mcp-overview,jadx-github,ghidra-github}.

\section{Taxonomies and severity scoring}
To communicate results and integrate with established workflows, crash judgements should map to standard taxonomies. \gls{cwe} provides a community-developed catalogue of weakness types \cite{cwe-mitre}; the \gls{cve} programme assigns identifiers to specific vulnerabilities \cite{cve-overview}. Severity can be expressed using \gls{cvss} v3.1 or v4.0, which define reproducible scoring formulas and vector strings suitable for automation \cite{cvss31,cvss40}. Our pipeline adopts these standards so that triage outputs are actionable for security engineering teams and compatible with existing disclosure and patch processes.

\section*{Provisional references for the Background}
Android app model and \gls{jni} \cite{art-doc,ndk-guide,jni-book,jni-tips}; memory-safety risks \cite{android-native-risk,cwe-mitre,cve-overview}; fuzzing and sanitizers \cite{aflpp-woot20,libfuzzer-llvm,asan-android-aosp,hwasan-ndk}; POIROT and harness generation landscape \cite{poirot-usenix25,atlas-issta24,fuzzgen-usenix20}; crash bucketing/triage \cite{scb-ase18,igor-ccs21}; tool grounding and supporting tools \cite{mcp-overview,jadx-github,ghidra-github}; severity/taxonomies \cite{cvss31,cvss40}.