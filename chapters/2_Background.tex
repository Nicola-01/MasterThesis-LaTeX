\chapter{Background}
\label{chp:backgroud}

\section{Android Native}
Android uses native C/C++ libraries at the \emph{platform} level: core components and services (e.g., runtime, HAL, system libraries) are implemented in native code, and the framework exposes part of this functionality to apps through Java/Kotlin \gls{api}s \cite{android-platform}. When third-party developers need to include their own C/C++ code, for example, to meet real-time constraints, reuse existing native libraries, or interface with vendor-specific hardware, he \gls{ndk} provides the toolchains and headers required to build and link native components that can be packaged within the \gls{apk}. At the system level, Android’s C library and dynamic linker are provided by \emph{Bionic}, the platform’s libc/libm/libdl stack \cite{bionic-maint}. In apps, these native components run inside the same process as the managed code and communicate with it through the \gls{jni} boundary \cite{jni-tips}. Figure~\ref{fig:androidStack} represents the Android platform architecture.

This capability of use native code, extends the reach of Android apps beyond the managed runtime but also introduces explicit responsibilities for developers. Native code must handle its own memory management, threading and exception handling. This is significantly different from pure Java/Kotlin development.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \def\W{8cm}
        \def\Wleft{4.46cm}
        \def\Wright{3.47cm}
        
        \node[layer, fill=cSystem!60, minimum width=\W] (apps) {System Apps};
        \node[layer, fill=cJava!60, minimum width=\W, below=0.5mm of apps] (java) {Java API Framework};
        \node[layer, fill=cNative!60, minimum width=\Wleft, below=0.5mm of java, anchor=west] (native) at ($(java.south west)+(0,-3.5mm)$) {Native C/C++ Libraries};
        \node[layer, fill=cRuntime!70, minimum width=\Wright, below=0.5mm of java, anchor=east] (runtime) at ($(java.south east)+(0,-3.5mm)$) {Android Runtime};
        \node[layer, fill=cHAL!60, minimum width=\W, below=8mm of java] (hal) {Hardware Abstraction Layer (HAL)};
        \node[layer, fill=cKernel!60, minimum width=\W, below=0.5mm of hal] (kernel) {Linux Kernel};
    \end{tikzpicture}
    \caption{Android software stack. }
    \label{fig:androidStack}
\end{figure}

\subsection{NDK}
The \gls{ndk} is a collection of tools, headers, and libraries that enable developers to embed C and C++ code within Android applications and interact natively with hardware, sensors, and system \gls{api}s \cite{android-ndk-getting-started}. The \gls{ndk} supports compilation into shared (and static) libraries that can be packaged inside the \gls{apk}, and offers native interfaces for tasks such as sensor input, asset loading, and more \cite{android-ndk-concepts}.

Developers typically adopt native code for three main reasons:
\begin{itemize}
  \item \textbf{Performance optimization:} achieving low-latency processing in compute-intensive domains such as graphics, signal processing, physics, or cryptography.
  \item \textbf{Library reuse:} integrating existing C/C++ libraries (e.g.\ cryptography, compression, codecs) to avoid rewriting functionality in Java/Kotlin.
  \item \textbf{Hardware or vendor-specific access:} interacting directly with low-level or proprietary \gls{api}s (e.g.\ custom sensors, specialized accelerators) not exposed in the Java framework.
\end{itemize}

However, using the \gls{ndk} comes with tradeoffs. Native development adds complexity in build configuration, cross-ABI support, debugging, and maintenance across Android versions. Not all Android \gls{api}s are directly available through the \gls{ndk}, so bridging via \gls{jni} is often required for broad framework functionality \cite{android-ndk-concepts}. 


\subsection{JNI}
The \gls{jni} (Java Native Interface) is a native programming interface that enables Java or Kotlin code running in a virtual machine to interoperate with libraries and applications written in C/C++ \cite{jni-spec-design,jni-spec-intro}. It allows managed code to call into native code, and for native code to call back into the \gls{vm}, manipulate Java objects, throw exceptions, and more. The \gls{jni} is designed to impose no restrictions on the implementation of the \gls{vm}, thereby preserving binary compatibility across \gls{vm} vendors \cite{jni-spec-intro}.  

Listing~\ref{lst:javaNative} shows a Java class declaring a \texttt{native} method, while Listing~\ref{lst:JNI} gives the corresponding C implementation on the native side.

\begin{lstlisting}[language=Java+JNI, caption={Java class declaring a \texttt{native} method}, label={lst:javaNative}] 
public class foo {
    private native double bar(int i, String s);
    
    static {
        System.loadLibrary("native-lib");
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C+JNI, caption={Native implementation of \texttt{bar}}, label={lst:JNI}]
jdouble Java_pkg_foo_bar(JNIEnv *env,   // ptr to JNI interface
                         jobject obj,   // "this" pointer
                         jint i,        // first "real" parameter
                         jstring s)     // second "real" parameter
{
    /* Method implementation */
    return 0.0;
}
\end{lstlisting}


\subsection{Vulnerabilities and impact under the Android sandbox}
Memory-safety bugs in native libraries (e.g., buffer overflows, out-of-bounds access, use-after-free) can yield \emph{app-compromise} (code execution or data exfiltration within the app UID) even when the managed layer is memory-safe. The Android application sandbox enforces per-UID isolation at the kernel level, strengthened by SELinux policy, which limits the direct blast radius to the permissions granted to the victim app \cite{android-app-sandbox,android-selinux,apsm-mayrhofer-2023}. In practice, this still covers sensitive assets (tokens, keystore-backed secrets, on-device content, and any resources accessible via the app’s declared permissions). Moreover, native vulnerabilities may act as stepping stones (e.g., pivoting through IPC endpoints) when combined with other weaknesses outside the app process. For engineering workflows, enabling \gls{hwasan} (preferable on modern \texttt{arm64}) or \gls{asan} in test builds materially improves detection fidelity and crash explainability, which is critical for downstream triage and exploitability assessment \cite{hwasan-aosp,asan-aosp,asan-ndk}.


\subsection{Security and diagnostics (brief)}
Because native code shares the app process, memory-safety bugs (e.g., buffer overflows, out-of-bounds access, use-after-free) can compromise integrity and confidentiality. During testing, enable sanitizers where feasible: \gls{asan} for detailed heap/stack diagnostics and \gls{hwasan} to catch temporal errors with lower overhead on ARMv8.5+ devices. These tools materially improve native defect detection during fuzzing and CI \cite{asan-aosp,hwasan-ndk}.




\begin{comment}
\section{Android application model and the \gls{jni} boundary}
Android apps run atop the \gls{art}, which executes \gls{dex} bytecode produced from Java/Kotlin sources and provides GC, \gls{jit}/\gls{aot} compilation, and a rich managed environment \cite{art-doc}. The \gls{ndk} allows apps to integrate C/C++ code and access platform libraries; developers typically adopt native code to reuse libraries or meet strict latency/throughput requirements \cite{ndk-guide}. \gls{jni} defines the cross-language interface: Java can call into native functions and native code can create/manipulate Java objects and invoke Java methods \cite{jni-book,jni-tips}. This boundary is bidirectional and stateful, and errors at the native side can corrupt process memory, affecting overall app integrity \cite{android-native-risk}.

\end{comment}
\section{Memory safety differences and vulnerability classes}
Java/Kotlin provide memory safety by construction (bounds checks, GC), whereas C/C++ delegate memory and lifetime management to the programmer, enabling classes of bugs that frequently underlie security vulnerabilities. Common weakness families include buffer overflow/underflow, use-after-free, out-of-bounds read/write, and double free; these are captured in \gls{cwe} and repeatedly observed in \gls{cve} records \cite{cwe-mitre,cve-overview}. On Android, such defects can lead to denial of service (crash) or arbitrary code execution, depending on mitigations and exploitability \cite{android-native-risk}.

\section{Fuzzing native libraries and harness generation}
Coverage-guided fuzzing mutates inputs to maximise code coverage while detecting crashes via sanitizers or OS signals. \gls{aflpp} generalises AFL’s greybox approach and incorporates state-of-the-art features (e.g., custom mutators) for broad applicability \cite{aflpp-woot20}. \gls{libfuzzer} integrates tightly with LLVM sanitizers and is widely used for in-process targets \cite{libfuzzer-llvm}. Sanitizers such as \gls{asan} and \gls{hwasan} are available on Android and provide precise diagnostics for memory-safety violations \cite{asan-android-aosp,hwasan-ndk}.

The limiting factor for library fuzzing is the harness: an executable environment that exercises target \gls{api}s with realistic sequences and well-formed objects. Automating harness synthesis for Android native libraries is challenging due to cross-language interactions, complex object lifecycles, and the need to emulate app-specific call sequences via \gls{jni}. POIROT addresses these challenges by statically analysing an app’s Java-side usage of the native library, synthesising a consumer-specific harness that supports bidirectional \gls{jni}, and running large-scale fuzzing campaigns \cite{poirot-usenix25}. Prior works on harness generation and Android library fuzzing (e.g., ATLAS, FuzzGen) highlight the broader landscape and the difficulty of scaling without app-specific context \cite{atlas-issta24,fuzzgen-usenix20}.

\section{Crash triage: principles and challenges}
Crash triage seeks to (i) deduplicate and bucket crashes, (ii) decide whether a crash indicates a security-relevant vulnerability, and (iii) prioritise fixes. Heuristic exploitability assessors and semantic crash bucketing methods have been proposed to improve accuracy and scalability, yet they typically assume desktop/server contexts and still require expert review \cite{scb-ase18,igor-ccs21}. On Android, crashes often originate in native code called through \gls{jni} and may depend on app-specific object invariants; reproducing and interpreting them benefits from reverse-engineering and sanitizer evidence \cite{poirot-usenix25,asan-android-aosp}.

\section{\gls{llm}s with tool grounding for security triage}
Emerging studies suggest that \gls{llm}s can assist in vulnerability management tasks such as \gls{cwe} classification and severity estimation. For instance, CASEY reports non-trivial accuracy for \gls{cwe} and severity identification on proprietary datasets, indicating potential to streamline triage workflows \cite{casey-aic25}. LProtector explores \gls{llm}-driven detection pipelines that combine static/dynamic signals with model judgements \cite{lprotector-2024}. However, unguided \gls{llm}s may hallucinate or misinterpret low-level details. Tool grounding mitigates this risk by connecting the model to program artefacts through \gls{mcp}, enabling retrieval of Jadx bytecode contexts, Android manifests, and Ghidra decompilation/disassembly snippets that can be quoted as evidence in triage outputs \cite{mcp-overview,jadx-github,ghidra-github}.

\section{Taxonomies and severity scoring}
To communicate results and integrate with established workflows, crash judgements should map to standard taxonomies. \gls{cwe} provides a community-developed catalogue of weakness types \cite{cwe-mitre}; the \gls{cve} programme assigns identifiers to specific vulnerabilities \cite{cve-overview}. Severity can be expressed using \gls{cvss} v3.1 or v4.0, which define reproducible scoring formulas and vector strings suitable for automation \cite{cvss31,cvss40}. Our pipeline adopts these standards so that triage outputs are actionable for security engineering teams and compatible with existing disclosure and patch processes.

\section*{Provisional references for the Background}
Android app model and \gls{jni} \cite{art-doc,ndk-guide,jni-book,jni-tips}; memory-safety risks \cite{android-native-risk,cwe-mitre,cve-overview}; fuzzing and sanitizers \cite{aflpp-woot20,libfuzzer-llvm,asan-android-aosp,hwasan-ndk}; POIROT and harness generation landscape \cite{poirot-usenix25,atlas-issta24,fuzzgen-usenix20}; crash bucketing/triage \cite{scb-ase18,igor-ccs21}; tool grounding and supporting tools \cite{mcp-overview,jadx-github,ghidra-github}; severity/taxonomies \cite{cvss31,cvss40}.