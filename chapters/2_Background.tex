\chapter{Background}
\label{chp:backgroud}

\section{Android application model and the \gls{jni} boundary}
Android apps run atop the \gls{art}, which executes \gls{dex} bytecode produced from Java/Kotlin sources and provides GC, \gls{jit}/\gls{aot} compilation, and a rich managed environment \cite{art-doc}. The \gls{ndk} allows apps to integrate C/C++ code and access platform libraries; developers typically adopt native code to reuse libraries or meet strict latency/throughput requirements \cite{ndk-guide}. \gls{jni} defines the cross-language interface: Java can call into native functions and native code can create/manipulate Java objects and invoke Java methods \cite{jni-book,jni-tips}. This boundary is bidirectional and stateful, and errors at the native side can corrupt process memory, affecting overall app integrity \cite{android-native-risk}.

\section{Memory safety differences and vulnerability classes}
Java/Kotlin provide memory safety by construction (bounds checks, GC), whereas C/C++ delegate memory and lifetime management to the programmer, enabling classes of bugs that frequently underlie security vulnerabilities. Common weakness families include buffer overflow/underflow, use-after-free, out-of-bounds read/write, and double free; these are captured in \gls{cwe} and repeatedly observed in \gls{cve} records \cite{cwe-mitre,cve-overview}. On Android, such defects can lead to denial of service (crash) or arbitrary code execution, depending on mitigations and exploitability \cite{android-native-risk}.

\section{Fuzzing native libraries and harness generation}
Coverage-guided fuzzing mutates inputs to maximise code coverage while detecting crashes via sanitizers or OS signals. \gls{aflpp} generalises AFL’s greybox approach and incorporates state-of-the-art features (e.g., custom mutators) for broad applicability \cite{aflpp-woot20}. \gls{libfuzzer} integrates tightly with LLVM sanitizers and is widely used for in-process targets \cite{libfuzzer-llvm}. Sanitizers such as \gls{asan} and \gls{hwasan} are available on Android and provide precise diagnostics for memory-safety violations \cite{asan-android-aosp,hwasan-ndk}.

The limiting factor for library fuzzing is the harness: an executable environment that exercises target APIs with realistic sequences and well-formed objects. Automating harness synthesis for Android native libraries is challenging due to cross-language interactions, complex object lifecycles, and the need to emulate app-specific call sequences via \gls{jni}. POIROT addresses these challenges by statically analysing an app’s Java-side usage of the native library, synthesising a consumer-specific harness that supports bidirectional \gls{jni}, and running large-scale fuzzing campaigns \cite{poirot-usenix25}. Prior works on harness generation and Android library fuzzing (e.g., ATLAS, FuzzGen) highlight the broader landscape and the difficulty of scaling without app-specific context \cite{atlas-issta24,fuzzgen-usenix20}.

\section{Crash triage: principles and challenges}
Crash triage seeks to (i) deduplicate and bucket crashes, (ii) decide whether a crash indicates a security-relevant vulnerability, and (iii) prioritise fixes. Heuristic exploitability assessors and semantic crash bucketing methods have been proposed to improve accuracy and scalability, yet they typically assume desktop/server contexts and still require expert review \cite{scb-ase18,igor-ccs21}. On Android, crashes often originate in native code called through \gls{jni} and may depend on app-specific object invariants; reproducing and interpreting them benefits from reverse-engineering and sanitizer evidence \cite{poirot-usenix25,asan-android-aosp}.

\section{\gls{llm}s with tool grounding for security triage}
Emerging studies suggest that \gls{llm}s can assist in vulnerability management tasks such as \gls{cwe} classification and severity estimation. For instance, CASEY reports non-trivial accuracy for \gls{cwe} and severity identification on proprietary datasets, indicating potential to streamline triage workflows \cite{casey-aic25}. LProtector explores \gls{llm}-driven detection pipelines that combine static/dynamic signals with model judgements \cite{lprotector-2024}. However, unguided \gls{llm}s may hallucinate or misinterpret low-level details. Tool grounding mitigates this risk by connecting the model to program artefacts through \gls{mcp}, enabling retrieval of Jadx bytecode contexts, Android manifests, and Ghidra decompilation/disassembly snippets that can be quoted as evidence in triage outputs \cite{mcp-overview,jadx-github,ghidra-github}.

\section{Taxonomies and severity scoring}
To communicate results and integrate with established workflows, crash judgements should map to standard taxonomies. \gls{cwe} provides a community-developed catalogue of weakness types \cite{cwe-mitre}; the \gls{cve} programme assigns identifiers to specific vulnerabilities \cite{cve-overview}. Severity can be expressed using \gls{cvss} v3.1 or v4.0, which define reproducible scoring formulas and vector strings suitable for automation \cite{cvss31,cvss40}. Our pipeline adopts these standards so that triage outputs are actionable for security engineering teams and compatible with existing disclosure and patch processes.

\section*{Provisional references for the Background}
Android app model and \gls{jni} \cite{art-doc,ndk-guide,jni-book,jni-tips}; memory-safety risks \cite{android-native-risk,cwe-mitre,cve-overview}; fuzzing and sanitizers \cite{aflpp-woot20,libfuzzer-llvm,asan-android-aosp,hwasan-ndk}; POIROT and harness generation landscape \cite{poirot-usenix25,atlas-issta24,fuzzgen-usenix20}; crash bucketing/triage \cite{scb-ase18,igor-ccs21}; tool grounding and supporting tools \cite{mcp-overview,jadx-github,ghidra-github}; severity/taxonomies \cite{cvss31,cvss40}.